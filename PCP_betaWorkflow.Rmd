---
title: "PCP_betaWorkflow"
author: "Will P."
date: "5/30/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 00: R Setup

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(sp)
library(ggplot2)
library(ggforce) # to plot circles
library(dplyr)
library(tidyverse)
library(geosphere) # for geodist
library(useful) # for cartesian conversions
library(akima) # for irregular grid
library(reshape2) # for contor/grid


```

## 01: Input CSV into R
* Read and give headers and datatypes for each (eventually do more sophisticated validation/type detection)

```{r}
# TEST DATA: only one at a time
dataFile <- "testData/IND_remittances.csv" # remittances to India in USD in 201X
# dataFile <- "testData/routes_bare_sm.csv" # flights to DTW
# dataFile <- "testData/routes_sm.csv" # flights to DTW with ORD and MSP options
# dataFile <- "testData/china1911_XJofficials.csv" # officials from Xinjiang in 1911

df <- read.csv(file = dataFile)

summary(df)
class(df) # test to make sure it's a data frame

# STORE COL NAMES FOR LATER

colListOrig <- colnames(df)
latNames <- list("lat","Lat","LAT", "latitude", "y","Y") # add as they come up
lonNames <- list("lon","Lon","LON","long","Long","LONG","longitude", "x","X")

# STARTING TO INCLUDE FORCED GENERIC COLUMN HEADINGS

df2 <- df # need to clean up df2 later, or initialize as an empty dataframe?

latflag <- 0 # need these here for the 
lonflag <- 0
ctrBinflag <- 0

for (col in 1:ncol(df)) {
  if (typeof(df[[col]]) == "double"
  && latflag == 0
  && max(as.numeric(df[[col]]), na.rm = T) <= 90.0
  && min(as.numeric(df[[col]]), na.rm = T) >= -90.0
  && names(df)[[col]] %in% latNames) # lat
  { print(paste("Found a lat column: ", names(df)[[col]]))
    df2$lat <- df[[col]]
    latflag <- 1}
  else{
    if (typeof(df[[col]]) == "double"
    && lonflag == 0
    && max(as.numeric(df[[col]]), na.rm = T) <= 180.0
    && min(as.numeric(df[[col]]), na.rm = T) >= -180.0
    && names(df)[col] %in% lonNames) # lon
    { print(paste("Found a lon column: ", names(df)[[col]]))
      df2$lon <- df[[col]]
      lonflag <- 1}
    else{
      if (typeof(df[[col]]) != "character"
      && min(as.numeric(df[[col]]), na.rm = T) == 0
      && max(as.numeric(df[[col]]), na.rm = T) == 1
      && sum(as.numeric(df[[col]]), na.rm = T) == 1) # ctrBin
      { df2$ctrBin <- as.logical(df[[col]])
        print(paste("Found a ctrBin column: ", names(df)[[col]]))
        ctrBinflag <- 1}
        else{
          if (typeof(df[[col]]) == "character" # catches name and name_long
          || is.factor(df[[col]]) == T) # valName
          { df2$valName <- as.character(df[[col]])
            print(paste("Found a valName column: ", names(df)[[col]]))}
          else{
          if (typeof(df[[col]]) == "integer" || typeof(df[[col]]) == "double" # val
          && !(names(df)[col] %in% lonNames)
          && !(names(df)[col] %in% latNames))
          { df2$val <- as.double(df[[col]])
            print(paste("Found a val column: ", names(df)[[col]]))}
          }
        }
    }
  }
}

df2 <- select(df2, valName, val, lat, lon, ctrBin) # just the fields we want

```



## 02: Plot test

```{r}

# test plot
plot(df$long, df$lat)

#temp ***
ctrX <- df$long[df$isCTR == TRUE]
ctrY <- df$lat[df$isCTR == TRUE]

#real
# ctrX <- df$long[df$ctrBin == TRUE]
# ctrY <- df$lat[df$ctrBin == TRUE]
ctrPt <- c(ctrX,ctrY)
cat("Your center point has the following coordinates:", ctrPt[1],"longitude and", ctrPt[2], "latitude. ")
```




## 04: Calculate all great circle distances and bearings to center point

* __NB:__ half of circumference of earth is ~20,000 km, which might be half of the max dist we should allow
    + example data max is 7,241 km

```{r}
# create a column in df, fill with km distances
  df$distance <- geodist(ctrY, ctrX, df$lat, df$long, units = "km")  
  maxdist <- max(df$distance) # max great circle distance

  print( # print out both the longest axial and great circle distances
    paste0("The longest great circle distance between your center point, ",
           df$valName[df$ctrBin == TRUE], ", and farthest point, ",
           df$valName[df$distance == max(df$distance)], ", is ",
           round(max(df$distance), 0), " km.")
    )
  
for (row in 1:nrow(df)){ # convert to polar coordinates
  valNamelong <- df[row,"long"]
  valNamelat <- df[row,"lat"]
  valNamelonglat <- c(valNamelong, valNamelat)
  df[row,"ctrPtGeobearing"] <- bearing(ctrPt, valNamelonglat, a=6378137, f=1/298.257223563)
}
  rm(valNamelat,valNamelong,valNamelonglat,row)
  
for (row in 1:nrow(df)) # convert from geographic bearings to polar coordinates
  {if(df$ctrPtGeobearing[row] <= 0)
  # if geobearing is 0 or negative, mathbearing is 90 plus bearing
  df$ctrPtMathbearing[row] <- abs(df$ctrPtGeobearing[row]) + 90
  if(df$ctrPtGeobearing[row] > 0 & df$ctrPtGeobearing[row] < 90)
  # if geobearing is positive and equal to or under 90, mathbearing is 90 - bearing
  df$ctrPtMathbearing[row] <- (90 - df$ctrPtGeobearing[row])
  if(df$ctrPtGeobearing[row] >= 90 & df$ctrPtGeobearing[row] <= 180)
  # if geobearing is positive and between 90 and 180 (inclusive), mathbearing is 360 - (geobearing - 90)
  df$ctrPtMathbearing[row] <- 360 - (df$ctrPtGeobearing[row] - 90)}
  rm(row)

  df <- select(df,-starts_with("ctrPtGeo"))
  # later we use the ctrPtMathbearing and the transformed distances to get back to cartesian coordinates

```

## 05: Initial plot
* GGplot of the lat and long with low-res world background

```{r}
# first plot with ctrPt and data visualized, still using lat/long
plot05 <- ggplot(df, 
       aes(df$long, 
           df$lat, 
           color = df$distance)) + 
           geom_point() + 
           geom_point(data = (as.data.frame(ctrPt)), aes(ctrPt[1], ctrPt[2]), color = "orange")

plot05

```  

## 06: Plot 2 - val center connectivity
* Plot connectivity
  
```{r} 
#temp ***
df$valTrans <- (df$IND_remit * 1) + .5 
#real
# *** NEED DATA DRIVEN TRANSFORMATION, not best guess from old test data
#df$valTrans <- (df$val * 1) + .5 

for (row in 1:nrow(df)){
  df[row,"circdistancex"] <- (pol2cart(df$distance[row], df$ctrPtMathbearing[row], degrees = TRUE))[1]
  df[row,"circdistancey"] <- (pol2cart(df$distance[row], df$ctrPtMathbearing[row], degrees = TRUE))[2]
}
rm(row)

# Lets make some circles
circles <- data.frame(
  x0 = 0,
  y0 = 0,
  r = seq(0, maxdist,length.out = 10)
)

# Use coord_fixed to ensure true circularity
ggplot() +
  geom_circle(aes(x0 = x0, y0 = y0, r = r), colour = "orange", data = circles, show.legend = NA, inherit.aes = FALSE) +
  coord_fixed()

plot06 <- ggplot(df, aes(
                df$circdistancex, 
                df$circdistancey, 
                color = df$distance)) +
        geom_circle(aes(x0 = x0, y0 = y0, r = r),
          colour = "orange", 
          data = circles, 
          show.legend = NA, 
          inherit.aes = FALSE) +
        geom_point(stroke = 1, size = df$valTrans) +
        geom_point(data = (as.data.frame(ctrPt)), aes(0, 0), color = "orange") +
        coord_fixed() + labs(color = "Distance in km", x = NULL, y = NULL) +
        guides(colour = "colorbar",size = "legend") +
        theme(panel.background = element_blank())

plot06

```  

## 07: Plot on log scale
an option we can give our users later
```{r} 
# replot on log scale

df$distancelog <- log(df$distance)

for (row in 1:nrow(df)){
  df[row,"distancelogcircx"] <- (pol2cart(df$distancelog[row], df$ctrPtMathbearing[row], degrees = TRUE))[1]
  df[row,"distancelogcircy"] <- (pol2cart(df$distancelog[row], df$ctrPtMathbearing[row], degrees = TRUE))[2]
}

logcircles <- data.frame()

for (row in 1:nrow(circles)){
  logcircles[row,"r"] <- log(circles[row,"r"])
  logcircles[row,"x0"] <- circles[row,"x0"]
  logcircles[row,"y0"] <- circles[row,"y0"]
}
rm(row)

plot07 <- ggplot(df, aes(
                df$distancelogcircx, 
                df$distancelogcircy, 
                color = df$distance)) + 
  geom_circle(aes(x0 = x0, y0 = y0, r = r), 
                      colour = "orange", data = logcircles, 
                      show.legend = NA, inherit.aes = FALSE) +
  geom_point(stroke = 1, size = df$valTrans) + 
  geom_point(data = (as.data.frame(ctrPt)), aes(0, 0), color = "orange") +
  coord_fixed() + labs(color = "Great circle distance in km", x = NULL, y = NULL) +
  theme(panel.background = element_blank(), axis.ticks = element_blank(),
                axis.text.x = element_blank(),axis.text.y = element_blank())

plot07

```  

## 08 Plot on square root scale (with and without scale circles)

```{r} 
df$distancesqrt <- sqrt(df$distance)

## *** GENERALIZE pol2cart function so can run on X rows and don't have to re-deploy every time 
for (row in 1:nrow(df)){ 
  df[row,"sqrtcircX"] <- (pol2cart(df$distancesqrt[row], df$ctrPtMathbearing[row], degrees = TRUE))[1]
  df[row,"sqrtcircY"] <- (pol2cart(df$distancesqrt[row], df$ctrPtMathbearing[row], degrees = TRUE))[2]
}
rm(row)

plot08A <- ggplot(df, aes( # plot with scale circles
                df$sqrtcircX, 
                df$sqrtcircY, 
                color = df$distance)) +  
          geom_circle(aes(x0 = x0, y0 = y0, r = r), 
                      colour = "orange", data = sqrt(circles), 
                      show.legend = NA, inherit.aes = FALSE) + 
          geom_point(stroke = 1, size = df$valTrans) + 
          geom_point(data = (as.data.frame(ctrPt)), aes(0, 0), color = "orange") + 
          coord_fixed() + 
          labs(color = "Distance in km", x = NULL, y = NULL) + 
          theme(panel.background = element_blank(), axis.ticks = element_blank(),
                axis.text.x = element_blank(),axis.text.y = element_blank())

plot08A

plot08B <- ggplot(df, aes( # plot without circles
                df$sqrtcircX, 
                df$sqrtcircY, 
                color = df$distance)) + 
          geom_point(stroke = 1, size = df$valTrans) + 
          geom_point(data = (as.data.frame(ctrPt)), aes(0, 0), color = "orange") + 
          coord_fixed() + 
          labs(color = "Distance in km", x = NULL, y = NULL) + 
          theme(panel.background = element_blank(), axis.ticks = element_blank(),
                axis.text.x = element_blank(),axis.text.y = element_blank())

plot08B

```


## 09: Manual Control Points
* Define a decay function using manual control points

```{r}
# polynom::poly
# code to find a Lagrange interpolation polynomial for our control points. for now I'm just defining some, later we should explore the user input and/or data-driven methods.

geogdist <- c(0, 500, 2000, maxdist) # let's say under 500 km is close, over 2000km is far
chartdist <- c(0, 400, 800, 1200) # this just gets us equal intervals on the graph for the different segments of the lines

neardist <- 500
fardist <- 2500

a <- function(x){ # here is some example code for the piecewise funciton
  ifelse(( x > 0 & x < neardist),(x * 400/neardist),ifelse((neardist <= x & x < fardist),((x * 400)/(fardist - neardist) + (400-((400)/(fardist - neardist)*neardist))), ifelse((fardist <= x & x <= maxdist),((x * 400)/(maxdist - fardist) + (800-((400)/(maxdist - fardist)*fardist))), NA))) 
} 
plot(a,xlim=c(0,maxdist), ylim = c(0, 1200), col = "red") 
abline(v = 0, h = 0)

dat <- data.frame(cbind(geogdist, chartdist)) # chart points to check intervals
ggplot(dat, aes(x=geogdist, y=chartdist)) + geom_point(size=5, col='blue') 

lagrangepoly <- poly.calc(geogdist, chartdist) # calculate polynomial from control points
lagrangepoly # print polynomial 

curve(predict(lagrangepoly,x), from = 0, to = maxdist, n = 100)

predict(lagrangepoly, 200) # print predicted value for geogdist of 200

a(maxdist) # print predicted value for geogdist of 200


df$lagrangedistcircstep <- a(df$distance) # set new lagrange great circle distances using new stepwise function

df$lagrangedistcirc <- predict(lagrangepoly, df$distance) # set new lagrange great circle distances using new polynomial

# function to make new circles with any lagrange polynomial set above
lagrange_predict <- function(circlesdataframe) { 
  lagrangecirclesdataframe <- circlesdataframe
  for (row in 1:nrow(circlesdataframe)){
    lagrangecirclesdataframe[row,"r"]<- predict(lagrangepoly, circlesdataframe[row,"r"])}
  return(lagrangecirclesdataframe)
}

lagrange_predictstep <- function(circlesdataframe) { 
  lagrangecirclesdataframe <- circlesdataframe
  for (row in 1:nrow(circlesdataframe)){
    lagrangecirclesdataframe[row,"r"]<- a(circlesdataframe[row,"r"])}
  return(lagrangecirclesdataframe)
}

lagrangecircles <- lagrange_predictstep(circles) # check if it worked

# lagrangecircles

```