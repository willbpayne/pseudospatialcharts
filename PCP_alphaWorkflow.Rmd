---
title: "PCP_alphaWorkflow"
author: "VanMcG"
date: "January 26, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sp)
library(ggplot2)
#library(dplyr)
#library(devtools)
#library(SpatialEpi)
#library(gmt) # geodist is in geosphere
library(tidyverse)
#library(sf)
library(geosphere)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## Input CSV into R
* Read and give headers and datatypes for each (eventually do more sophisticated validation/type detection)

```{r}
routes <- read.csv(file = "testData/routes_bare_sm.csv")

routes <- routes[!(routes$lat>50 | routes$long < -125),]
summary(routes)
# at some point, we need to enforce generic column headers

typeof(routes$isDTW)

     # obnoxiously explicit validation

if (typeof(routes$airport) != "character")
  routes$airport <- as.character(routes$airport)
if (typeof(routes$isDTW) != "logical")
  routes$isDTW <- as.logical(routes$isDTW)
if (typeof(routes$lat) != "double")
  routes$isDTW <- as.double(routes$lat)
if (typeof(routes$long) != "double")
  routes$isDTW <- as.double(routes$long)
if (typeof(routes$flightsDTW) != "integer" && typeof(routes$flightsDTW) != "double" )
  routes$flightsDTW <- as.double(routes$flightsDTW)

typeof(routes$isDTW)

```

## Plot test
```{r}
# coordinate validation
ifelse(max(routes$lat > 90.0) || min(routes$lat < -90.0) || max(routes$long > 180.0) || min(routes$long < -180.0), print("Check your coordinate system..."), print("Coordinates look ok!"))

# test plot
plot(routes$long, routes$lat)
```

## Select origin point from rows
* column "iscenter" value = 1
    + __currently pre-set in test data__
* validate that there is only one center

```{r}
if (sum(routes$isDTW) > 1)
  print("Too many centers. Check data")
if (sum(routes$isDTW) == 0)
    print("No center. Check data. Maybe we'll have an interface to select one later")
if (sum(routes$isDTW) == 1)
  print("There is one center! Hooray!")
```

## Declare a data frame; make it an object we want to use

```{r}
class(routes)
```

## Coordinates
* Go through lat and long
* Calculate distance (pairs) btwn all pairs and origin
     + __important__ right angle indiv coorinate distance, not diagonal pt distance
     + eg, dist btwn X(a) and X(1) in km assuming constant Lat, not dist btwn X(a),Y(a) and X(1),Y(1)
          + also __surely there's a library for this__ : spDistN1? recs from geodessy-dorks? library geosphere?
* Save values as new columns called latDist and lonDist
* Find max dist of any value within latDist OR lonDist
     + WP: this would probably eff up a basemap, but helpful for us in our analytical purpose. 
     + __NB:__ do we need to think more about great circles?
* set bounding box for plot and save for later
     + Take maxVal and double for height and width of bounding box
          + This solves some of our hypotenuse fears bc max coord dist still captured
     + not a proper bounding box, setting an extent, but don't necessarily need to declare lat/long coordos ()

```{r}


# give DTW row an id
#if(distMat$isDTW == 1) print("nearly there")
ctrX <- routes$long[routes$isDTW == TRUE]
ctrY <- routes$lat[routes$isDTW == TRUE]
ctrPt <- c(ctrX,ctrY)
ctrPt

# Test point
# HNL is approx 7120km from DTW
HNLx <- routes$long[routes$airport == "HNL"]
HNLy <- routes$lat[routes$airport == "HNL"]

HNLpt <- c(HNLx,HNLy)

# test distance
geodist(ctrY, ctrX, HNLy, HNLx, units = "km")
  # test passed



```

# Distance
* Find longest distance between origin and any other point (RADIANS? GREAT CIRCLES? GEOGRAPHY?)

```{r}
# currently in km

  # create a column in routes call distance
    # EM: I added a few options here, but we should trim for final product

  # fill with km distances
routes$distance <- geodist(ctrY, ctrX, routes$lat, routes$long, units = "km")  
  # fill with km horiz distances
routes$distanceX <- geodist(ctrY, ctrX, ctrY, routes$long, units = "km")  
  # fill with km vert distances
routes$distanceY <- geodist(ctrY, ctrX, routes$lat, ctrX, units = "km")  

# find max distance
# assign variable to max dist
  maxdistPT <- max(routes$distance) # distance of real points
  maxdistX <- max(routes$distanceX) # longest EW dist
  maxdistY <- max(routes$distanceY) # longest NS dit
  maxdist <- max(routes$distanceX, routes$distanceY) # max between NS and EW distances
  # cheating because I know it's X dist here, but we should write a test to find out
  maxXcoord <- routes$long[routes$distanceX == maxdistX]
```

# Units
* Convert this measurement in degrees into kilometers, and show user "The great circle distance between your origin, POINTNAME1, and farthest point, POINTNAME2, is X km"
* Save this measurement = var longestdistance (float)
* __NB:__ half of circumference of earth is ~20,000 km, which might be half of the max dist we should allow
    + example data max is 7,241 km

```{r}
print(
  paste0("The greatest distance between your origin, ",
         routes$airport[routes$isDTW == TRUE], ", and farthest point, ",
         routes$airport[routes$distance == max(routes$distance)], ", is ",
         round(max(routes$distance), 0), " km.")
  )


```

## Plot
* GGplot of the lat and long with low-res world background
* REPROJECT on logarithmic scale
* GGplot again

```{r}
# first plot
ggplot(routes, aes(routes$long, routes$lat, color = routes$distance)) + geom_point() + geom_point(data = (as.data.frame(ctrPt)), aes(ctrPt[1], ctrPt[2]), color = "orange")


# determine if maxCoord is NSEW of ctrPt
# http://mathforum.org/library/drmath/view/51816.html ?

# take the maxdist
earthrad <- 6371

# radius of earth in km: 6,371 km
latS <- asin((sin(ctrY)*cos(maxdist/earthrad))
             +(cos(ctrY)*sin(maxdist/earthrad)*cos(180)))


latS <- asin(sin(ctrY)*cos(maxdist/earthrad) + cos(ctrY)*sin(maxdist/earthrad)*cos(180))

latN <- asin(sin(ctrY)*cos(maxdist/earthrad)+cos(ctrY)*sin(maxdist/earthrad))
latN

latNdist <- geodist(ctrY, ctrX, latN, ctrX, units = "km")
latNdist
maxdist

# variation based on ed williams for less-than-half-the-earth-distances
# ugh, I cleaned my environment and pi is still effed up. Here's a bunch of digits
pi <- 3.141592653589793238462643383279502884197169399375105820974944592307816406286 

# a different answer ~ -36S, that is also wrong
latS_alt <- asin(sin(ctrY)*cos(maxdist/earthrad)+cos(ctrY)*sin(maxdist/earthrad)*cos(2*pi))
    ifelse((cos(ctrY) == 0),
       lonS_alt <- ctrX,
       lonS_alt <- ((ctrX-asin(sin(2*pi)*sin(maxdist/earthrad)/cos(latS_alt)) + pi) %% pi) - pi
    )


# lat=asin(sin(lat1)*cos(d)+cos(lat1)*sin(d)*cos(tc))
#      IF (cos(lat)=0)
#         lon=lon1      // endpoint a pole
#      ELSE
     #    lon=mod(lon1-asin(sin(tc)*sin(d)/cos(lat))+pi,2*pi)-pi
     # ENDIF

  
    
# var δ = d/R;
# var Δφ = δ * Math.cos(θ);
# var φ2 = φ1 + Δφ;
# 
# var Δψ = Math.log(Math.tan(φ2/2+Math.PI/4)/Math.tan(φ1/2+Math.PI/4));
# var q = Math.abs(Δψ) > 10e-12 ? Δφ / Δψ : Math.cos(φ1); // E-W course becomes ill-conditioned with 0/0
# 
# var Δλ = δ*Math.sin(θ)/q;
# var λ2 = λ1 + Δλ;


# mod() = %%
lonE = (ctrX+asin(sin(3*pi/2)*sin(maxdist/6366.565)/cos(ctrY))+pi %% 2*pi)-pi ## ARGH!

# lonE = mod(lon1+asin(sin(tc)*sin(d)/cos(lat))+pi,2*pi)-pi

latE <- 
  # E, W (tc=pi/2 or 3*pi/2): lat = asin(sin(lat1)*cos(d))

# GAH, not right!! ^^^

# N (tc=0): lat = asin(sin(lat1)*cos(d)+cos(lat1)*sin(d))
#               = asin(sin(lat1 + d)
#               = lat1 + d

    # cheating example
#           N (tc=0): lat = asin(sin(lat1)*cos(d)+cos(lat1)*sin(d))
#               = asin(sin(lat1 + d)
#               = lat1 + d
# 
# S (tc=pi): lat = asin(sin(lat1)*cos(d)-cos(lat1)*sin(d))
#                = asin(sin(lat1 - d)
#                = lat1 - d
# 
# E, W (tc=pi/2 or 3*pi/2): lat = asin(sin(lat1)*cos(d))


# The circle example

    # added pkg sf

sfdf <- st_sfc(st_point(cbind(ctrY, ctrX)),crs=4326)
df_sf_buff <- st_buffer(sfdf, (maxdist*10)) #meters*10
plot(df_sf_buff) 
points(routes$long, routes$lat)

# circle in ggplot
ggplot(routes, aes(routes$long, routes$lat, color = routes$distance)) + geom_point() + theme_bw()
  
  ggplot((as.data.frame(ctrPt)), aes(ctrPt[1], ctrPt[2])) + geom_point(color = "Orange")
  # then would add a big buffer. Gah.
```  
  
Ah crap, that was painful, no?
Here's something closer to working below
  
  
  
```{r}  
# geosphere::geodesic

latLon_S <- geodesic(ctrPt, 180, (maxdist*1000), f=1/298.257223563)

latLon_N <- geodesic(ctrPt, 0, (maxdist*1000), f=1/298.257223563)

latLon_E  <- geodesic(ctrPt, 90, (maxdist*1000), f=1/298.257223563)

latLon_W  <- geodesic(ctrPt, 270, (maxdist*1000), f=1/298.257223563)

limPts <- data.frame(longitude = double(), latitude = double(), azimuth = numeric())
limPts <- rbind(latLon_N,latLon_S,latLon_E,latLon_W)
limPts <- as.data.frame(limPts)

# now we make a data.frame of all the geodesic results

  xlim1 <- limPts$longitude[limPts$longitude == min(limPts$longitude)]
  xlim2 <- limPts$longitude[limPts$longitude == max(limPts$longitude)]
  ylim1 <- limPts$latitude[limPts$latitude == min(limPts$latitude)]
  ylim2 <- limPts$latitude[limPts$latitude == max(limPts$latitude)]

# some algebra to get xlim of long via km maxdistX in other position
# ditto for ylim


ggplot(routes, aes(routes$long, routes$lat, color = routes$distance)) + geom_point() + geom_point(data = (as.data.frame(ctrPt)), aes(ctrPt[1], ctrPt[2]), color = "orange") + xlim(xlim1,xlim2) + ylim(ylim1,ylim2)

# determine if maxCoord is NSEW of ctrPt

# replot on log scale

```

