---
title: "PCP_alphaWorkflow"
author: "VanMcG"
date: "January 26, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sp)
library(ggplot2)
library(dplyr)
library(devtools)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## Input CSV into R
* Read and give headers and datatypes for each (eventually do more sophisticated validation/type detection)

```{r}
routes <- read.csv(file = "testData/routes_bare_sm.csv")
summary(routes)
# at some point, we need to enforce generic column headers

typeof(routes$isDTW)

     # obnoxiously explicit validation

if (typeof(routes$airport) != "character")
  routes$airport <- as.character(routes$airport)
if (typeof(routes$isDTW) != "logical")
  routes$isDTW <- as.logical(routes$isDTW)
if (typeof(routes$lat) != "double")
  routes$isDTW <- as.double(routes$lat)
if (typeof(routes$long) != "double")
  routes$isDTW <- as.double(routes$long)
if (typeof(routes$flightsDTW) != "integer" && typeof(routes$flightsDTW) != "double" )
  routes$flightsDTW <- as.double(routes$flightsDTW)

typeof(routes$isDTW)

```

## Plot test
```{r}
# coordinate validation
ifelse(max(routes$lat > 90.0) || min(routes$lat < -90.0) || max(routes$long > 180.0) || min(routes$long < -180.0), print("Check your coordinate system..."), print("Coordinates look ok!"))

# test plot
plot(routes$long, routes$lat)
```

## Select origin point from rows
* column "iscenter" value = 1
    + __currently pre-set in test data__
* validate that there is only one center

```{r}
if (sum(routes$isDTW) > 1)
  print("Too many centers. Check data")
if (sum(routes$isDTW) == 0)
    print("No center. Check data. Maybe we'll have an interface to select one later")
if (sum(routes$isDTW) == 1)
  print("There is one center! Hooray!")
```

## Declare a data frame; make it an object we want to use

```{r}
class(routes)
```

## Coordinates
* Go through lat and long
* Calculate distance (pairs) btwn all pairs and origin
     + __important__ right angle indiv coorinate distance, not diagonal pt distance
     + eg, dist btwn X(a) and X(1) in km assuming constant Lat, not dist btwn X(a),Y(a) and X(1),Y(1)
          + also __surely there's a library for this__ : spDistN1? recs from geodessy-dorks? library geosphere?
* Save values as new columns called latDist and lonDist
* Find max dist of any value within latDist OR lonDist
     + WP: this would probably eff up a basemap, but helpful for us in our analytical purpose. 
     + __NB:__ do we need to think more about great circles?
* set bounding box for plot and save for later
     + Take maxVal and double for height and width of bounding box
          + This solves some of our hypotenuse fears bc max coord dist still captured
     + not a proper bounding box, setting an extent, but don't necessarily need to declare lat/long coordos ()

```{r}
# make an array with long/lat as columns 1 &2 and isDTW as column 3
distMat <- routes[c(4,3)]
distMat <- as.matrix(distMat)

# give DTW row an id
#if(distMat$isDTW == 1) print("nearly there")
ctrX <- routes$long[routes$isDTW == TRUE]
ctrY <- routes$lat[routes$isDTW == TRUE]
ctrPt <- c(ctrX,ctrY)
ctrPt

# run latlong2grid to turn to km
# do we need this?
# I think so
latlong2grid

# run spdistsn1 to find distances
distMat_result <- spDistsN1(distMat, ctrPt, longlat = TRUE)

as.data.frame(distMat_result)

max(distMat_result)

# find max distance
# assign variable to max dist
    # maxdist <- max()

```

# Distance
* Find longest distance between origin and any other point (RADIANS? GREAT CIRCLES? GEOGRAPHY?)

```{r}

```

# Units
* Convert this measurement in degrees into kilometers, and show user "The great circle distance between your origin, POINTNAME1, and farthest point, POINTNAME2, is X km"
* Save this measurement = var longestdistance (float)

```{r}

```

## Plot
* GGplot of the lat and long with low-res world background
* REPROJECT on logarithmic scale
* GGplot again

```{r}

```

