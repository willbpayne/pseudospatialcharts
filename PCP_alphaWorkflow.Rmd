---
title: "PCP_alphaWorkflow"
author: "VanMcG"
date: "January 26, 2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(sp)
library(ggplot2)
#library(dplyr)
#library(devtools)
#library(SpatialEpi)
library(gmt)
library(tidyverse)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

## Input CSV into R
* Read and give headers and datatypes for each (eventually do more sophisticated validation/type detection)

```{r}
routes <- read.csv(file = "testData/routes_bare_sm.csv")
summary(routes)
# at some point, we need to enforce generic column headers

typeof(routes$isDTW)

     # obnoxiously explicit validation

if (typeof(routes$airport) != "character")
  routes$airport <- as.character(routes$airport)
if (typeof(routes$isDTW) != "logical")
  routes$isDTW <- as.logical(routes$isDTW)
if (typeof(routes$lat) != "double")
  routes$isDTW <- as.double(routes$lat)
if (typeof(routes$long) != "double")
  routes$isDTW <- as.double(routes$long)
if (typeof(routes$flightsDTW) != "integer" && typeof(routes$flightsDTW) != "double" )
  routes$flightsDTW <- as.double(routes$flightsDTW)

typeof(routes$isDTW)

```

## Plot test
```{r}
# coordinate validation
ifelse(max(routes$lat > 90.0) || min(routes$lat < -90.0) || max(routes$long > 180.0) || min(routes$long < -180.0), print("Check your coordinate system..."), print("Coordinates look ok!"))

# test plot
plot(routes$long, routes$lat)
```

## Select origin point from rows
* column "iscenter" value = 1
    + __currently pre-set in test data__
* validate that there is only one center

```{r}
if (sum(routes$isDTW) > 1)
  print("Too many centers. Check data")
if (sum(routes$isDTW) == 0)
    print("No center. Check data. Maybe we'll have an interface to select one later")
if (sum(routes$isDTW) == 1)
  print("There is one center! Hooray!")
```

## Declare a data frame; make it an object we want to use

```{r}
class(routes)
```

## Coordinates
* Go through lat and long
* Calculate distance (pairs) btwn all pairs and origin
     + __important__ right angle indiv coorinate distance, not diagonal pt distance
     + eg, dist btwn X(a) and X(1) in km assuming constant Lat, not dist btwn X(a),Y(a) and X(1),Y(1)
          + also __surely there's a library for this__ : spDistN1? recs from geodessy-dorks? library geosphere?
* Save values as new columns called latDist and lonDist
* Find max dist of any value within latDist OR lonDist
     + WP: this would probably eff up a basemap, but helpful for us in our analytical purpose. 
     + __NB:__ do we need to think more about great circles?
* set bounding box for plot and save for later
     + Take maxVal and double for height and width of bounding box
          + This solves some of our hypotenuse fears bc max coord dist still captured
     + not a proper bounding box, setting an extent, but don't necessarily need to declare lat/long coordos ()

```{r}


# give DTW row an id
#if(distMat$isDTW == 1) print("nearly there")
ctrX <- routes$long[routes$isDTW == TRUE]
ctrY <- routes$lat[routes$isDTW == TRUE]
ctrPt <- c(ctrX,ctrY)
ctrPt

# Test point
# HNL is approx 7120km from DTW
HNLx <- routes$long[routes$airport == "HNL"]
HNLy <- routes$lat[routes$airport == "HNL"]

HNLpt <- c(HNLx,HNLy)

# test distance
geodist(ctrY, ctrX, HNLy, HNLx, units = "km")
  # test passed



```

# Distance
* Find longest distance between origin and any other point (RADIANS? GREAT CIRCLES? GEOGRAPHY?)

```{r}
# currently in km

  # create a column in routes call distance
    # EM: I added a few options here, but we should trim for final product

  # fill with km distances
routes$distance <- geodist(ctrY, ctrX, routes$lat, routes$long, units = "km")  
  # fill with km horiz distances
routes$distanceX <- geodist(ctrY, ctrX, ctrY, routes$long, units = "km")  
  # fill with km vert distances
routes$distanceY <- geodist(ctrY, ctrX, routes$lat, ctrX, units = "km")  

# find max distance
# assign variable to max dist
  maxdistPT <- max(routes$distance) # distance of real points
  maxdistX <- max(routes$distanceX) # longest EW dist
  maxdistY <- max(routes$distanceY) # longest NS dit
  maxdist <- max(routes$distanceX, routes$distanceY) # max between NS and EW distances
  # cheating because I know it's X dist here, but we should write a test to find out
  maxXcoord <- routes$long[routes$distanceX == maxdistX]
```

# Units
* Convert this measurement in degrees into kilometers, and show user "The great circle distance between your origin, POINTNAME1, and farthest point, POINTNAME2, is X km"
* Save this measurement = var longestdistance (float)
* __NB:__ half of circumference of earth is ~20,000 km, which might be half of the max dist we should allow
    + example data max is 7,241 km

```{r}
print(
  paste0("The greatest distance between your origin, ",
         routes$airport[routes$isDTW == TRUE], ", and farthest point, ",
         routes$airport[routes$distance == max(routes$distance)], ", is ",
         round(max(routes$distance), 0), " km.")
  )


```

## Plot
* GGplot of the lat and long with low-res world background
* REPROJECT on logarithmic scale
* GGplot again

```{r}
# first plot
ggplot(routes, aes(routes$long, routes$lat, color = routes$distance)) + geom_point() + theme_bw()

# determine if maxCoord is NSEW of ctrPt
# http://mathforum.org/library/drmath/view/51816.html ?

# take the maxdist
earthrad <- 6371

# radius of earth in km: 6,371 km
latS <- asin((sin(ctrY)*cos(maxdist/earthrad))
             +(cos(ctrY)*sin(maxdist/earthrad)*cos(180)))


latS <- asin(sin(ctrY)*cos(maxdist/earthrad) + cos(ctrY)*sin(maxdist/earthrad)*cos(180))

latN <- asin(sin(ctrY)*cos(maxdist/earthrad)+cos(ctrY)*sin(maxdist/earthrad))
latN

latNdist <- geodist(ctrY, ctrX, latN, ctrX, units = "km")
latNdist
maxdist

pi = 
# mod() = %%
lonE = (ctrX+asin(sin(3*pi/2)*sin(maxdist/6366.565)/cos(ctrY))+pi %% 2*pi)-pi ## ARGH!

# lonE = mod(lon1+asin(sin(tc)*sin(d)/cos(lat))+pi,2*pi)-pi

latE <- 
  # E, W (tc=pi/2 or 3*pi/2): lat = asin(sin(lat1)*cos(d))

# GAH, not right!! ^^^

# N (tc=0): lat = asin(sin(lat1)*cos(d)+cos(lat1)*sin(d))
#               = asin(sin(lat1 + d)
#               = lat1 + d

    # cheating example
#           N (tc=0): lat = asin(sin(lat1)*cos(d)+cos(lat1)*sin(d))
#               = asin(sin(lat1 + d)
#               = lat1 + d
# 
# S (tc=pi): lat = asin(sin(lat1)*cos(d)-cos(lat1)*sin(d))
#                = asin(sin(lat1 - d)
#                = lat1 - d
# 
# E, W (tc=pi/2 or 3*pi/2): lat = asin(sin(lat1)*cos(d))

# some algebra to get xlim of long via km maxdistX in other position
# ditto for ylim

# determine if maxCoord is NSEW of ctrPt

# replot
# + xlim(maxXcoord, OPPOSITE_maxXcoord)
# + ylim( SOME MATH ABOUT DISTANCE )

# replot on log scale

```

